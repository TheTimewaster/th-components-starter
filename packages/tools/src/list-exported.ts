import ts from 'typescript';
import * as fs from 'fs';
import * as glob from 'glob';
import { consola } from 'consola';
import path from 'path';
import { parseArgs } from 'node:util';

type ModuleType = 'composables' | 'components';

const {
  values: { outDir, inDir },
} = parseArgs({
  options: {
    outDir: {
      type: 'string',
      short: 'o',
      default: './constants',
    },
    inDir: {
      type: 'string',
      short: 'i',
      default: './src',
    },
  },
});

if (outDir == null || inDir == null) {
  consola.error('Please provide the outDir and inDir options');
  process.exit(1);
}

// Define aliases for the paths
// TODO: take aliases from tsconfig.json
const aliases = {
  '@composables': 'src/composables',
  '@components': 'src/components',
};

consola.start(`Creating modules list from ${inDir}...`);
const mode = await consola.prompt('Do you want to export components or composables or both', {
  type: 'select',
  options: ['both', 'components', 'composables'],
  initial: 'both',
});

// first make sure, that the outDir exists
if (!fs.existsSync(outDir)) {
  consola.info(`Creating directory ${outDir}`);
  fs.mkdirSync(outDir);
} else {
  consola.info(`Cleaning directory ${outDir}`);
  // otherwise clean the directory
  fs.rmSync(outDir, { recursive: true });
  fs.mkdirSync(outDir);
}

/**
 *
 * @param normalizedPath - the normalized path to the file
 * @param symbolText - the symbol text to look for
 * @param extensions - the file extensions to look for
 * @returns
 */
const addModuleByExtension = (normalizedPath: string, symbolText: string, extensions: Array<string>) => {
  const ret: string[] = [];
  // first test, if the path exists and is a directory, we want to skip that
  if (fs.existsSync(normalizedPath) && fs.lstatSync(normalizedPath).isDirectory()) return ret;

  // next up, test if the file exists with given extensions
  extensions.forEach((ext) => {
    const fullExtension = `.${ext}`;
    let fileName = normalizedPath;
    if (!normalizedPath.endsWith(fullExtension)) {
      // if the symbol text does not end with the file extension, we will add it
      fileName += fullExtension;
    }

    // otherwise test if the file exists
    if (fs.existsSync(fileName) && fs.lstatSync(fileName).isFile()) {
      ret.push(symbolText.replace(fullExtension, ''));
    }
  });

  return ret;
};
// Function to get all exported symbols
function getExportedModules(indexFile: ts.SourceFile, extract: ModuleType): string[] {
  const exportedModules: string[] = [];
  // console.log(sourceFile.fileName, sourceFile.getChildren());

  ts.forEachChild(indexFile, (node) => {
    if (ts.isExportDeclaration(node) && node.moduleSpecifier != null) {
      // get only symbol from the text and exclude any file extension
      const text = node.moduleSpecifier.getText().replace(/['"]/g, '');

      let normalizedPath: string | null = null;
      // in case the text starts with a alias, we have to replace it with the actual path
      const alias = Object.keys(aliases).find((key) => text.startsWith(key));
      const symbolText = text.split('/').pop();

      if (alias != null) {
        const normalizedBase = indexFile.fileName.replace('index.ts', '').replace(alias, aliases[alias]);
        normalizedPath = path.join(normalizedBase, text.replace(alias, ''));
      } else if (symbolText != null) {
        normalizedPath = indexFile.fileName.replace('index.ts', symbolText.replace('./', ''));
      }

      if (normalizedPath != null && symbolText != null) {
        // based on the current location of the index.ts, we have to look for a relative path

        if (extract === 'composables') {
          const modules = addModuleByExtension(normalizedPath, symbolText, ['ts', 'js']);
          exportedModules.push(...modules);
        } else {
          const modules = addModuleByExtension(normalizedPath, symbolText, ['vue']);
          exportedModules.push(...modules);

          // in case the component is a typescript file, we have to put this into consideration
        }
      }
    }
  });

  return exportedModules;
}

const writeToFile = (exportedMap: Record<string, Array<string>>, moduleType: ModuleType) => {
  fs.writeFileSync(
    `${outDir}/${moduleType}.ts`,
    `
  /**
   * This file is auto-generated by the list-modules.ts script!
   * Do not modify this file manually!
   * 
   * This file contains all exported components from the src directory and its subdirectories
   * and is used for tooling purposes.
   */
  export default ${JSON.stringify(exportedMap, null, 2)};
  `,
  );
};

// Get all index.ts files in the src directory and its subdirectories
const indexFiles = glob.sync(inDir + '/**/index.ts');

// Create a program with the index.ts files
const program = ts.createProgram(indexFiles, {});
const checker = program.getTypeChecker();

const extractModules = (file: string, sourceFile: ts.SourceFile, moduleType: ModuleType) => {
  if ((mode === 'both' || mode === moduleType) && file.indexOf(moduleType) >= 0) {
    // composables need other handling than components
    const exportedModules = getExportedModules(sourceFile, moduleType);

    let adjustedKey = file.replace(inDir, '');
    if (adjustedKey.startsWith('/')) {
      adjustedKey = adjustedKey.slice(1);
    }

    if (exportedModules.length > 0) {
      return { exportedModules, adjustedKey };
    }
  }

  return { exportedModules: [], adjustedKey: '' };
};

// Get all exported modules from each index.ts file
const exportedModules = indexFiles.reduce<Record<ModuleType, Record<string, Array<string>>>>(
  (acc, file) => {
    // exclude the src/index.ts file
    // TODO: take inDir into consideration
    if (file.indexOf('src/index.ts') >= 0) return acc;

    // here we want to separate composables and components
    // skip the file if it's not the type we want
    if (mode === 'composables' && file.indexOf('composables') >= 0) return acc;
    if (mode === 'components' && file.indexOf('composables') >= 0) return acc;

    const sourceFile = program.getSourceFile(file);

    if (sourceFile == null) return acc;

    const composables = extractModules(file, sourceFile, 'composables');
    if (composables.exportedModules.length > 0) {
      if (acc.composables == null) {
        acc.composables = {};
      }
      acc.composables[composables.adjustedKey] = composables.exportedModules;
    }

    const components = extractModules(file, sourceFile, 'components');
    if (components.exportedModules.length > 0) {
      if (acc.components == null) {
        acc.components = {};
      }
      acc.components[components.adjustedKey] = components.exportedModules;
    }

    return acc;
  },
  {} as Record<ModuleType, Record<string, Array<string>>>,
);

writeToFile(exportedModules.composables, 'composables');
writeToFile(exportedModules.components, 'components');

if (mode === 'both' || mode === 'composables') {
  consola.info('Exported components:', Object.values(exportedModules.composables).flat().length);
  consola.success(`Modules file created to ${outDir}/composables.ts`);
}

if (mode === 'both' || mode === 'components') {
  consola.info('Exported composables:', Object.values(exportedModules.components).flat().length);
  consola.success(`Modules file created to ${outDir}/components.ts`);
}

consola.success('Done! ðŸŽ‰');
